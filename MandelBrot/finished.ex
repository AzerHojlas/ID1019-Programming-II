defmodule Cmplx do
  def new(r, i) do
      {:rect_cmplx, r, i}
  end

  def add(a, b) do
      {:rect_cmplx, a1, a2} = a
      {:rect_cmplx, b1, b2} = b
      {:rect_cmplx, a1 + b1, a2 + b2}
  end

  def angle(a) do
      {:rect_cmplx, r, i} = a
      cond do
          r == 0 -> :math.pi / 2
          true -> :math.atan(i / r)
      end
  end

  def polar(a) do
      {:rect_cmplx, r, _} = a
      length = absolute(a)
      angle_res = angle(a)
      cond do
          r >= 0 -> {:polar_cmplx, length, angle_res}
          r < 0 -> {:polar_cmplx, length, angle_res + :math.pi}
      end
  end

  def sqrt_cmplx(a) do
      {:polar_cmplx, _, angle} = polar(a)
      distance = absolute(a)
      new_real = :math.cos(angle / 2) * distance
      new_imaginary = :math.sin(angle / 2) * distance
      {:rect_cmplx, new_real, new_imaginary}
  end

  def sqr(a) do
      {:rect_cmplx, r, i} = a
      {:rect_cmplx, r * r - i * i, 2 * r * i}
  end

  def absolute(a) do
      {:rect_cmplx, a, b} = a
      :math.sqrt(a * a + b * b)
  end
end

defmodule Brot do
  # c = complex number, m = depth
  # z_(n + 1) = z_(n) ^ 2 + C, C = z_(0)
  def mandelbrot(c, m) do
      z0 = Cmplx.new(0, 0)
      i = 0
      test(i, z0, c, m)
  end

  # def test(i, z0, c, m) do
  #     cond do
  #         Cmplx.absolute(c) > 2 -> Cmplx.new(0, 1)
  #         i >= m -> Cmplx.new(0, 0)
  #         true ->
  #             new_num = Cmplx.add(Cmplx.sqr(c), z0)
  #             test(i + 1, z0, new_num, m)
  #     end
  # end

  def test(i, z, c, m) do
      cond do
          Cmplx.absolute(z) > 2 -> i
          i + 1 >= m -> 0
          true ->
              new_num = Cmplx.add(Cmplx.sqr(z), c)
              test(i + 1, new_num, c, m)
      end
  end
end

defmodule PPM do

  # write(name, image) The image is a list of rows, each row a list of
  # tuples {R,G,B}. The RGB values are 0-255.

  def write(name, image) do
      height = length(image)
      width = length(List.first(image))
      {:ok, fd} = File.open(name, [:write])
      IO.puts(fd, "P6")
      IO.puts(fd, "#generated by ppm.ex")
      IO.puts(fd, "#{width} #{height}")
      IO.puts(fd, "255")
      rows(image, fd)
      File.close(fd)
  end

  defp rows(rows, fd) do
      Enum.each(rows, fn(r) ->
      colors = row(r)
      IO.write(fd, colors)
      end)
  end

  defp row(row) do
      List.foldr(row, [], fn({:rgb, r, g, b}, a) ->
      [r, g, b | a]
      end)
  end

end

defmodule Color do
  # depth = what to sort
  # max = the max placements it can be sorted
  # return int for rgb
  # def convert(depth, max) do
  #     rgb_steps = 255 / max
  #     number = checker(rgb_steps, depth)
  #     {:rgb, number, number, number}
  # end

  # def checker(steps, depth) do
  #     cond do
  #         depth <= steps -> steps
  #         true -> checker(steps * 2, depth)
  #     end
  # end

  # THIS WORKS JUST THE STANDARD ONE GIVEN

  def convert(depth, max) do
      division = depth / max
      position = division * 4
      real_position = Kernel.trunc(position)
      x = real_position
      y = Kernel.trunc(255 * (position - x))
      case x do
          0 -> {:rgb, y, 0, 0}
          1 -> {:rgb, 255, y, 0}
          2 -> {:rgb, 255 - y, 255, 0}
          3 -> {:rgb, 0, 255, y}
          4 -> {:rgb, 0, 255 - y, 255}
      end
  end

  # def convert(depth, max) do
  #     division = depth / max
  #     position = division * 4
  #     real_position = Kernel.trunc(position)
  #     x = real_position
  #     y = Kernel.trunc(255 * (position - x))
  #     #{:rgb, y, y, y}
  #     #{:rgb, 255 - y, 255 - y, 255 - y}
  # end

  # def convert(depth, max) do
  #     division = depth / max
  #     position = division * 5
  #     real_position = Kernel.trunc(position)
  #     x = real_position
  #     y = Kernel.trunc(255 * (position - x))
  #     case x do
  #         0 -> {:rgb, depth, 0, 0}
  #         1 -> {:rgb, 0, depth, 0}
  #         2 -> {:rgb, 0, 0, depth}
  #         3 -> {:rgb, depth, 255, 255}
  #         4 -> {:rgb, 255, depth, 255}
  #         5 -> {:rgb, 255, 255, depth}
  #     end
  #     #{:rgb, depth, depth, depth}
  # end
end

defmodule Mandel do
  def mandelbrot(width, height, x, y, k, depth) do
      trans = fn(w, h) ->
          Cmplx.new(x + k * (w - 1), y - k * (h - 1))
      end

      rows(width, height, trans, depth, [])
  end

  def rows(width, height, trans, depth, list) do
      row_check(width, height, width, height, trans, depth, list, [])
  end

  # def row_check(width, height, w_counter, h_counter, trans, depth, list, row) do
  #     cond do
  #         w_counter <= 0 && h_counter >= height -> list
  #         w_counter <= 0 -> row_check(width, height, width, (h_counter + 1), trans, depth, row ++ list, [])
  #         true ->
  #             number = trans(w_counter, h_counter)
  #             mandel_check = Brot.mandelbrot(number, depth)
  #             {:rect_cmplx, r, i} = mandel_check
  #             rgb_color = Color.convert(r + i, depth)
  #             row_check(width, height, (w_counter - 1), h_counter, trans, depth, list, [rgb_color | row])
  #     end
  # end

  def row_check(width, height, w_counter, h_counter, trans, depth, list, row) do
      cond do
          w_counter <= 0 && h_counter <= 0 ->
              list
          w_counter <= 0 ->
              row_check(width, height, width, (h_counter - 1), trans, depth, [row] ++ list, [])
          true ->
              cmplx_number = trans.(w_counter, h_counter)
              number_depth = Brot.mandelbrot(cmplx_number, depth)
              rgb_color = Color.convert(number_depth, depth)
              row_check(width, height, (w_counter - 1), h_counter, trans, depth, list, [rgb_color | row])
      end
  end

end

defmodule Demo do
  def demo() do
      small(-2.6, 1.2, 1.2)
  end

  def small(x0, y0, xn) do
      width = 960
      height = 540
      depth = 64
      k = (xn - x0) / width
      image = Mandel.mandelbrot(width, height, x0, y0, k, depth)
      PPM.write("small.ppm", image)
  end

  def custom(x0, y0, xn, width, height, depth) do
      k = (xn - x0) / width
      image = Mandel.mandelbrot(width, height, x0, y0, k, depth)
      PPM.write("small.ppm", image)
  end
end

defmodule Timer do
  # from: https://stackoverflow.com/questions/29668635/how-can-we-easily-time-function-calls-in-elixir
  def measure(function) do
      function
      |> :timer.tc
      |> elem(0)
      |> Kernel./(1_000_000)
  end
end
